\lesson{10}{15.11.2023}{Сортировки. Сжатие и защита информации.}

\section{Сжатие по Хаффману}

\begin{eg}(из Романовского)

    Рассмотрим текст из 223 знаков:

    \begin{verbatim}
       
        ехали_медведи_на_велосипеде_а_за_ними_кот_задом
        _наперед_а_за_ним_комарики_на_воздушном_шарике_а
        _за_ними_раки_на_хромой_собаке_волки_на_кобыле_
        львы_в_автомобиле_зайчики_в_трамвайчике_жаба_
        на_метле_едут_и_смеются_пряники_жуют

    \end{verbatim}

    Применение сжатия по Хаффману дает следующий результат:

    \begin{verbatim}
        яь 3 жю 4 ыч 4 хш 4 йу 6 пяь 6 сб 8 жюыч 8 зхш 10
        йупяь 12 тр 14 лд 14 сбжюыч 16 взхш 20 нк 22 мйупяь 24
        отр 27 лдсбжюыч 30 евзхш 36 инк 42 амйупяь 48
        отрлдсбжюыч 57 евзхш_ 76 инкамйупяь 90
        отрлдсбжюычевзхш_ 133
    \end{verbatim}

    Если взять кодовые последовательности для этих символов и закодировать ими текст,
    получим сжатие до 119 байтов, что почти вдвое меньше исходного текста.
\end{eg}

Но код Хаффмана никак не учитывет закономерность распределения символов в тексте, поэтому
он не является оптимальным.

\section{Сжатие по Лемпелю-Зиву (LZ77, LZ78, LZO, LZMA, LZW etc.)}

\begin{algoritm}
    
    Основная идея: Кодируемый текст разбивается 
    на небольшие строки, каждая из которых 
    составлена из одной из предыдущих строк 
    (предопределена пустая строка, имеющая номер 0) и еще одного символа. 
    Сначала записаны номера строк, затем сами 
    строки, затем представление каждой из этих 
    строк в виде пар (номер предыдущей строки‚ дополняющий символ). 
\end{algoritm}

\begin{eg}
    На примере текста "aababaacbbbcccaaaaa": (сначала строки, затем представление строк в виде пар (номер предыдущей строки и дополняющий символ), затем номер строки)

    \begin{verbatim}
         a ab aba ac  b bb  c cc aa aaa
        0a 1b  2a 1c 0b 5b 0c 7c 1a  9a
         1  2   3  4  5  6  7  8  9  10
    \end{verbatim}
\end{eg}

\section{Метод Барроуза-Уилера (BWT)}

Рассмотрим две строки: $aababbbbaa$ и $aaaaabbbbb$. Вторая лучше с точки зрения сжатия, потому что она устроена проще.

Обычные тексты устроены сложнее, в них не просто буквы повторяются, а целые буквосочетания (например, артикли).

Идея преобразования Барроуза-Уилера (BWT — Barrous-Wheeler transformation) в том, чтобы так переставить буквы, чтобы:

\begin{enumerate}
    \item одинаковые буквы по возможности шли подряд;
    \item по преобразованной строке можно восстановить исходную.
\end{enumerate}

Но это только преобразование, а не сжатие, ведь перестановки букв длину текста не уменьшают.

\begin{algoritm}
    \begin{enumerate}
        \item В конец строки добавляем специальный символ, минимальный лексикографически (для обратного преобразования)
        \item Выписываем всем возможные циклические сдвиги строки.
        \item Сортируем их лексикографически.
        \item В качестве результата берем последний столбец полученной матрицы.
    \end{enumerate}

    $\newline$

    Обратное преобразование:
    \begin{enumerate}
        \item Берем исходную строку и записываем в первый столбец матрицы.
        \item Сортируем строки матрицы лексикографически и записываем в следующий столбец.
        \item Записываем в следующий столбец предыдущий + исходная строка слева.
        \item Продолжаем, пока не получим столбец, в котором длина строк равна длине исходной строки, берем из этого столбца ту строку, в которой послений символ -- специальный.
    \end{enumerate}
\end{algoritm}

\begin{eg}
    Имеется строка $\text{каркаркар}$. Добавляем в конец специальный символ, например, $\$$.

    \begin{verbatim}
        каркаркар$      $каркаркар
        аркаркар$к      ар$каркарк
        ркаркар$ка      аркар$карк
        каркар$кар      аркаркар$к
        аркар$карк      кар$каркар
        ркар$карка      каркар$кар
        кар$каркар      каркаркар$
        ар$каркарк      р$каркарка
        р$каркарка      ркар$карка
        $каркаркар      ркаркар$ка
    \end{verbatim}

    Получили строку $\text{ркккрр\$ааа}$, которая и будет результатом преобразования.

    $\newline$
    Обратное преобразование:

    \begin{verbatim}
        0 1  2  3  4     ...       n
        р $ р$ $к р$к    ...   $каркаркар
        к а ка ар кар    ...   ар$каркарк
        к а ка ар кар    ...   аркар$карк
        к а ка ар кар    ...   аркаркар$к
        р к рк ка рка    ...   кар$каркар
        р к рк ка рка    ...   каркар$кар
        $ к $к ка $ка    ...   каркаркар$
        а р ар р$ ар$    ...   р$каркарка
        а р ар рк арк    ...   ркар$карка
        а р ар рк арк    ...   ркаркар$ка
    \end{verbatim}

    Получили строку каркаркар\$
\end{eg}

\begin{remark}(на лекции этого не было, но посчитал это важным.)
    Преобразование и в ту, и в другую сторону можно реализовать за линейное время. (докажите сами...)
\end{remark}

Для того, чтобы преобразование Барроуза-Уилера имело смысл, нужно применить к полученной строке алгоритм сжатия.

\begin{algoritm}[MTF (Move To Front)] 
    Заведем вспомогательный массив, в котром будем хранить уникальные символы на текущей итерации. При встрече символа будет вставлять его в начало массива.
    Также заведем массив индексов, в котором будем хранить позиции символов в массиве уникальных символов.
    \begin{enumerate}
        \item Начальное положение: в массив уникальных символов записываем текущий элемент, в массив индексов записываем 0.
        \item На i-ой итерации: если символа нет в массиве уникальных символов, то записываем его в начало массива, иначе находим его позицию в массиве и записываем эту позицию в массив индексов.
    \end{enumerate}

    По итогу получим на выходе алфавит и набор индексов, по которым можно легко декодировать исходную строку.
\end{algoritm}

\begin{eg}
    $\newline$

    \begin{verbatim}
        i 
        0: р 0 р
        1: к 0 кр
        2: к 1 кр
        3: к 1 кр
        4: р 2 рк
        5: р 1 рк
        6: $ 0 $рк
        7: а 0 а$рк
        8: а 1 а$рк
        9: а 1 а$рк
       10: а 1 а$рк
    \end{verbatim}
\end{eg}


Далее получившийся набор индексов можно закодировать с помощью кода Хаффмана.