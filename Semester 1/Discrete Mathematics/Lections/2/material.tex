
%\setcounter{chapter}{-1}

\lesson{2}{20.09.2023}{Разбиения, прямое произведение, нумерация}

\begin{theorem}
    Произведение разбиений существует.
\end{theorem}

\begin{proof}
    $\mathcal{A}, \mathcal{B}$ --- разбиения.

    Возьмем все множества вида $C_{ij} = A_i \cap B_j$

    \begin{itemize}
        \item C --- измельчение $\mathcal{A}$, так как $\forall C_{ij} \; \exists A_i: C_{ij} \subset A_i$
        \item аналогично C --- измельчение $\mathcal{B}$
    \end{itemize}

    Предположим, что $F$ --- измельчение, большее $C$, тогда:

    $\forall F_k: \begin{cases}
        \exists A_i: F_k \subset A_i \\
        \exists B_i: F_k \subset B_i 
    \end{cases} \implies F_k \subset A_i \cap B_j \implies F_k \subset C_{ij}$ --- C наибольшее из измельчений.
\end{proof}

\chapter{Алгоритмы перебора}

\section{Перебор 0-1 векторов}

Будем рассматривать множество $B^m$ всех наборов из $m$ битов, каждый из которых может быть нулем и единицей. Элемент множества $B^m$ --- вектор $(0, 0, 1, \ldots, 1)$ длиной $m$. Количество элементов в множестве (мощность): $|B^m| = 2^m$.

Для того, чтобы создать вычислительный процесс, при котором на каждом шаге будет формироваться новый, не встречавшийся ранее, элемент рассматриваемого множества, достаточно заметить, что существует взаимнооднозначное соответствие между числами из $0…2^m - 1$ и наборами 0-1 векторов. Т. е. достаточно первым взять число 0 и его двоичное представление $(0,\ldots, 0)$, а затем просто добавлять по единице, имитируя это на текущем наборе, пока мы не дойдем до набора из одних единиц.

Кроме рассмотренного способа перебора наборов, можно предложить другой алгоритм, который на каждом шаге меняет значение только одной компоненты:

\begin{algoritm} (Перебор и нумерация 0-1 векторов в порядке минимального изменения)
    
    \begin{itemize}
        \item создаем 2 набора $x$ и $y$, каждый из $m$ битов. Первоначально $x = y = (0, 0, 0, 0)$
        \item прибавляем к $x$ единицу и фиксируем позицию $j$, где произошло изменение.
        \item изменить j-ую компоненту в наборе $y: y_j = 1 - y_j$
        \item вернуть $y$ 
    \end{itemize}

\end{algoritm}

\begin{eg} (Рассмотрим на примере $m = 4$)
    
    \begin{tabular}{|c|c|c|}
        \hline
        x & y & j \\
        \hline
        0000 & 0000 & - \\
        \hline
        0001 & 0001 & 4 \\
        \hline
        0010 & 0011 & 3 \\
        \hline
        0011 & 0010 & 4 \\
        \hline
        0100 & 0110 & 2 \\
        \hline
        0101 & 0111 & 4 \\
        \hline
        
      \end{tabular}
\end{eg}

\section{Перебор прямого произведения}

Рассматриваем множество $M(1:k) = M_1 \times M_2 \times \ldots \times M_k$. Число элементов: $\prod_{i\in1:k} m_i,$ где $m_i = |M_i|$.

Будем считать, что каждое $M_i$ состоит из $m_i$ элементов, которые мы будем нумеровать от 0 до $m_i - 1$. Тогда каждый элемент $M(1:k)$ --- последовательность неотрицательных чисел $(r_1, \ldots, r_k), r_i < m_i$

Общая формула перехода от элемента $(r_1, \ldots, r_k)$ к номеру этого элемента:

$$num(r_1, \ldots, r_k) = \sum_{i=1}^{k} \times (\prod_{j=1}^{i-1}m_j)$$


\section{Перебор перестановок}

Рассмотрим множество $T_k = M_1 \times M_2 \times \ldots \times M_k, M_i = \{0, 1, \ldots, i - 1\}, |T_k| = k!$. Обозначим множество всех перестановок из k элементов через $P_k$.

Построим взаимнооднозначное соответствие между $T_k$ и $P_k$. Возьмем перестановку $(r_1, \ldots, r_k)$ и сопоставим ей элемент $(t_1, \ldots, t_k)$ следующим образом: $\forall i \in 1:k$ найдем число значений, меньших $r_i$ среди $r_{i+1}, \ldots, r_k$ --- это число перепишем в качестве $t_i$.

%В соответствии с таким определением $t_i$ определим $T_k = M_k \times M_{k-1} \times \ldots \times M_1$

\begin{eg}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
        \hline
        i & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
        \hline
        $r_i$ & 4 & 8 & 1 & 5 & 7 & 2 & 3 & 6 \\
        \hline
        $t_i$ & 3 & 6 & 0 & 2 & 3 & 0 & 0 & 0 \\
        \hline
        %$m_i$ & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 \\
        %\hline
    \end{tabular}

    Чтобы получить перестановку по записи $(t_1, \ldots, t_k)$, нужно помнить множество значений $S_i$, которые могут быть в перестановке на i-ом месте. Так, $S_1 = 1:8, t_1 = 3$ означает, что $r_1 = 4$. Далее $S_2 = 1:3 \cup 5:8, t_2 = 6$ значит, что $r_2 = 8$
\end{eg}

\begin{remark}
    Если использовать отображение из примера при переборре, то перестановки будут идти в лексикографическом порядке Это значит, что:

    $(r_1, \ldots, r_k)$ предшествует $(R_1, \ldots, R_k) \Leftrightarrow$ начала этих перестановок совпадают до $i$ индекса, а далее $r_i < R_i$ 
\end{remark}

\begin{remark}
    Очевидно, что если факториальная запись $(t_1, \ldots, t_k)$ лексикографически предшествует другой, то порядок верен и для соответствующих перестановок.
\end{remark}

\begin{algoritm} (Перебор перестановок в лексикографическом порядке)

    \begin{enumerate}
        \item в заданной перестановке $(r_1, \ldots, r_k)$ найдем наибольший суффикс $(r_t, \ldots, r_k)$, в котором элементы расположены по убыванию.
        \item выбрать в $(r_t, \ldots, r_k)$ элемент, следующий по велечине после $r_{t-1}$ и поставить его на $r_{t-1}$. Оставшиеся эелменты, включая $r_{t-1}$ расположить за ним в порядке возрастания.
    \end{enumerate}
\end{algoritm}

\begin{eg}
    \begin{tabular}{ccccccccc}
        3 & 4 & 2 & 1 & 7 & 8 & 9 & 5 & \textbf{6} \\
        3 & 4 & 2 & 1 & 7 & 8 & \textbf{9} & \textbf{6} & \textbf{5} \\
        3 & 4 & 2 & 1 & 7 & 9 & 5 & 6 & \textbf{8} \\
        3 & 4 & 2 & 1 & 7 & 9 & 5 & \textbf{8} & \textbf{6} \\
        3 & 4 & 2 & 1 & 7 & 9 & 6 & 5 & \textbf{8} \\
        3 & 4 & 2 & 1 & 7 & 9 & 6 & \textbf{8} & \textbf{5} \\
        3 & 4 & 2 & 1 & 7 & 9 & 8 & 5 & \textbf{6} \\
        3 & 4 & 2 & 1 & 7 & \textbf{9} & \textbf{8} & \textbf{6} & \textbf{5} \\
        3 & 4 & 2 & 1 & 8 & 5 & 6 & 7 & \textbf{9} \\
    \end{tabular}
\end{eg}             